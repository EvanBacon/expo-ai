diff --git a/node_modules/babel-preset-expo/build/server-actions-plugin.js b/node_modules/babel-preset-expo/build/server-actions-plugin.js
index 6c7dd52..f8fd0c8 100644
--- a/node_modules/babel-preset-expo/build/server-actions-plugin.js
+++ b/node_modules/babel-preset-expo/build/server-actions-plugin.js
@@ -101,13 +101,58 @@ function reactServerActionsPlugin(api) {
         const functionDeclaration = t.exportNamedDeclaration(t.variableDeclaration(bindingKind, [
             t.variableDeclarator(extractedIdentifier, extractedFunctionExpr),
         ]));
-        // TODO: this is cacheable, no need to recompute
-        const programBody = moduleScope.path.get('body');
-        const lastImportPath = findLast(Array.isArray(programBody) ? programBody : [programBody], (stmt) => stmt.isImportDeclaration());
-        const [inserted] = lastImportPath.insertAfter(functionDeclaration);
-        moduleScope.registerBinding(bindingKind, inserted);
-        inserted.addComment('leading', ' hoisted action: ' + (getFnPathName(path) ?? '<anonymous>'), true);
+        // Insert the declaration as close to the original declaration as possible.
+        const isPathFunctionInTopLevel = path.find((p) => p.isProgram()) === path;
+        const decl = isPathFunctionInTopLevel ? path : findImmediatelyEnclosingDeclaration(path);
+        let inserted;
+        const canInsertExportNextToPath = (decl) => {
+            if (!decl) {
+                return false;
+            }
+            if (decl.parentPath?.isProgram()) {
+                return true;
+            }
+            return false;
+        };
+        const findNearestPathThatSupportsInsertBefore = (decl) => {
+            let current = decl;
+            // Check if current scope is suitable for `export` insertion
+            while (current && !current.isProgram()) {
+                if (canInsertExportNextToPath(current)) {
+                    return current;
+                }
+                const parentPath = current.parentPath;
+                if (!parentPath) {
+                    return null;
+                }
+                current = parentPath;
+            }
+            if (current.isFunction()) {
+                // Don't insert exports inside functions
+                return null;
+            }
+            return current;
+        };
+        const topLevelDecl = decl ? findNearestPathThatSupportsInsertBefore(decl) : null;
+        if (topLevelDecl) {
+            // If it's a variable declaration, insert before its parent statement to avoid syntax errors
+            const targetPath = topLevelDecl.isVariableDeclarator()
+                ? topLevelDecl.parentPath
+                : topLevelDecl;
+            [inserted] = targetPath.insertBefore(functionDeclaration);
+            moduleScope.registerBinding(bindingKind, inserted);
+            inserted.addComment('leading', ' hoisted action: ' + (getFnPathName(path) ?? '<anonymous>'), true);
+        }
+        else {
+            // Fallback to inserting after the last import if no enclosing declaration is found
+            const programBody = moduleScope.path.get('body');
+            const lastImportPath = findLast(Array.isArray(programBody) ? programBody : [programBody], (stmt) => stmt.isImportDeclaration());
+            [inserted] = lastImportPath.insertAfter(functionDeclaration);
+            moduleScope.registerBinding(bindingKind, inserted);
+            inserted.addComment('leading', ' hoisted action: ' + (getFnPathName(path) ?? '<anonymous>'), true);
+        }
         return {
+            inserted,
             extractedIdentifier,
             getReplacement: () => getInlineActionReplacement({
                 id: extractedIdentifier,
@@ -200,7 +245,7 @@ function reactServerActionsPlugin(api) {
                     throw path.buildCodeFrameError('Internal error: expected FunctionDeclaration to have a name');
                 }
                 const freeVariables = getFreeVariables(path);
-                const { extractedIdentifier, getReplacement } = extractInlineActionToTopLevel(path, state, {
+                const { extractedIdentifier, getReplacement, ...inlineAction } = extractInlineActionToTopLevel(path, state, {
                     freeVariables,
                     body: path.node.body,
                 });
@@ -211,8 +256,6 @@ function reactServerActionsPlugin(api) {
                     // so we can't just remove this node.
                     // replace the function decl with a (hopefully) equivalent var declaration
                     // `var [name] = $$INLINE_ACTION_{N}`
-                    // TODO: this'll almost certainly break when using default exports,
-                    // but tangle's build doesn't support those anyway
                     const bindingKind = 'var';
                     const [inserted] = path.replaceWith(t.variableDeclaration(bindingKind, [t.variableDeclarator(fnId, extractedIdentifier)]));
                     tlb.scope.registerBinding(bindingKind, inserted);
@@ -510,7 +553,7 @@ const getFreeVariables = (path) => {
     return [...freeVariablesSet].sort();
 };
 const getFnPathName = (path) => {
-    return path.isArrowFunctionExpression() ? undefined : path.node.id.name;
+    return path.isArrowFunctionExpression() ? undefined : path.node?.id?.name;
 };
 const isChildScope = ({ root, parent, child, }) => {
     let curScope = child;
